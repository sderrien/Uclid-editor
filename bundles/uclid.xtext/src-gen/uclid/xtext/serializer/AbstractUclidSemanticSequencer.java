/*
 * generated by Xtext 2.24.0
 */
package uclid.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uclid.xtext.services.UclidGrammarAccess;
import uclid.xtext.uclid.ArgList;
import uclid.xtext.uclid.ArgMapListRule;
import uclid.xtext.uclid.ArgMapRule;
import uclid.xtext.uclid.ArrayTypeRule;
import uclid.xtext.uclid.Assignment;
import uclid.xtext.uclid.AxiomDeclRule;
import uclid.xtext.uclid.CallStatement;
import uclid.xtext.uclid.CaseBlockRule;
import uclid.xtext.uclid.CaseStmtRule;
import uclid.xtext.uclid.CmdRule;
import uclid.xtext.uclid.CompoundStatement;
import uclid.xtext.uclid.ConstDecl;
import uclid.xtext.uclid.ConstRule;
import uclid.xtext.uclid.ConstsDeclRule;
import uclid.xtext.uclid.ControlBlockRule;
import uclid.xtext.uclid.DefaultCaseBlockRule;
import uclid.xtext.uclid.E10Rule;
import uclid.xtext.uclid.E12Rule;
import uclid.xtext.uclid.E1Rule;
import uclid.xtext.uclid.E2Rule;
import uclid.xtext.uclid.E3Rule;
import uclid.xtext.uclid.E4Rule;
import uclid.xtext.uclid.E5Rule;
import uclid.xtext.uclid.E6Rule;
import uclid.xtext.uclid.E7Rule;
import uclid.xtext.uclid.E8Rule;
import uclid.xtext.uclid.E9Rule;
import uclid.xtext.uclid.EnsureExprsRule;
import uclid.xtext.uclid.EnumRef;
import uclid.xtext.uclid.EnumTypeRule;
import uclid.xtext.uclid.EnumValue;
import uclid.xtext.uclid.ExprListRule;
import uclid.xtext.uclid.ForLoopRule;
import uclid.xtext.uclid.FuncDecl;
import uclid.xtext.uclid.FunctionDecl;
import uclid.xtext.uclid.IdListRule;
import uclid.xtext.uclid.IfPrimaryExpr;
import uclid.xtext.uclid.IfStmtRule;
import uclid.xtext.uclid.InitDeclRule;
import uclid.xtext.uclid.InputDecl;
import uclid.xtext.uclid.InputsDeclRule;
import uclid.xtext.uclid.InstanceDecl;
import uclid.xtext.uclid.InvariantRule;
import uclid.xtext.uclid.ModifiesExprsRule;
import uclid.xtext.uclid.NextDeclRule;
import uclid.xtext.uclid.OutputDecl;
import uclid.xtext.uclid.OutputsDeclRule;
import uclid.xtext.uclid.ProcReturnArgRule;
import uclid.xtext.uclid.ProcedureDecl;
import uclid.xtext.uclid.PropertyRule;
import uclid.xtext.uclid.RecordTypeRule;
import uclid.xtext.uclid.RequireExprsRule;
import uclid.xtext.uclid.SharedVarsDeclRule;
import uclid.xtext.uclid.Statement;
import uclid.xtext.uclid.StatementRule;
import uclid.xtext.uclid.TopLevel;
import uclid.xtext.uclid.TupleExpr;
import uclid.xtext.uclid.TupleTypeRule;
import uclid.xtext.uclid.Type;
import uclid.xtext.uclid.TypeDecl;
import uclid.xtext.uclid.UclidPackage;
import uclid.xtext.uclid.VarDecl;
import uclid.xtext.uclid.VarReference;
import uclid.xtext.uclid.VarsDeclRule;
import uclid.xtext.uclid.WhileLoopRule;

@SuppressWarnings("all")
public abstract class AbstractUclidSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UclidGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UclidPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UclidPackage.ARG_LIST:
				sequence_ArgList(context, (ArgList) semanticObject); 
				return; 
			case UclidPackage.ARG_MAP_LIST_RULE:
				sequence_ArgMapListRule(context, (ArgMapListRule) semanticObject); 
				return; 
			case UclidPackage.ARG_MAP_RULE:
				sequence_ArgMapRule(context, (ArgMapRule) semanticObject); 
				return; 
			case UclidPackage.ARRAY_TYPE_RULE:
				sequence_ArrayTypeRule(context, (ArrayTypeRule) semanticObject); 
				return; 
			case UclidPackage.ASSIGNMENT:
				sequence_AssignmentRule(context, (Assignment) semanticObject); 
				return; 
			case UclidPackage.AXIOM_DECL_RULE:
				sequence_AxiomDeclRule(context, (AxiomDeclRule) semanticObject); 
				return; 
			case UclidPackage.CALL_STATEMENT:
				sequence_CallStatement(context, (CallStatement) semanticObject); 
				return; 
			case UclidPackage.CASE_BLOCK_RULE:
				sequence_CaseBlockRule(context, (CaseBlockRule) semanticObject); 
				return; 
			case UclidPackage.CASE_STMT_RULE:
				sequence_CaseStmtRule(context, (CaseStmtRule) semanticObject); 
				return; 
			case UclidPackage.CMD_RULE:
				sequence_CmdRule(context, (CmdRule) semanticObject); 
				return; 
			case UclidPackage.COMPOUND_STATEMENT:
				sequence_BlkStmtRule(context, (CompoundStatement) semanticObject); 
				return; 
			case UclidPackage.CONST_DECL:
				sequence_ConstDecl(context, (ConstDecl) semanticObject); 
				return; 
			case UclidPackage.CONST_RULE:
				sequence_ConstRule(context, (ConstRule) semanticObject); 
				return; 
			case UclidPackage.CONSTS_DECL_RULE:
				sequence_ConstsDeclRule(context, (ConstsDeclRule) semanticObject); 
				return; 
			case UclidPackage.CONTROL_BLOCK_RULE:
				sequence_ControlBlockRule(context, (ControlBlockRule) semanticObject); 
				return; 
			case UclidPackage.DEFAULT_CASE_BLOCK_RULE:
				sequence_DefaultCaseBlockRule(context, (DefaultCaseBlockRule) semanticObject); 
				return; 
			case UclidPackage.E10_RULE:
				sequence_E10Rule(context, (E10Rule) semanticObject); 
				return; 
			case UclidPackage.E12_RULE:
				if (rule == grammarAccess.getE11RuleRule()) {
					sequence_E11Rule_E12Rule(context, (E12Rule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getE12RuleRule()) {
					sequence_E12Rule(context, (E12Rule) semanticObject); 
					return; 
				}
				else break;
			case UclidPackage.E1_RULE:
				sequence_E1Rule(context, (E1Rule) semanticObject); 
				return; 
			case UclidPackage.E2_RULE:
				sequence_E2Rule(context, (E2Rule) semanticObject); 
				return; 
			case UclidPackage.E3_RULE:
				sequence_E3Rule(context, (E3Rule) semanticObject); 
				return; 
			case UclidPackage.E4_RULE:
				sequence_E4Rule(context, (E4Rule) semanticObject); 
				return; 
			case UclidPackage.E5_RULE:
				sequence_E5Rule(context, (E5Rule) semanticObject); 
				return; 
			case UclidPackage.E6_RULE:
				sequence_E6Rule(context, (E6Rule) semanticObject); 
				return; 
			case UclidPackage.E7_RULE:
				sequence_E7Rule(context, (E7Rule) semanticObject); 
				return; 
			case UclidPackage.E8_RULE:
				sequence_E8Rule(context, (E8Rule) semanticObject); 
				return; 
			case UclidPackage.E9_RULE:
				sequence_E9Rule(context, (E9Rule) semanticObject); 
				return; 
			case UclidPackage.ENSURE_EXPRS_RULE:
				sequence_EnsureExprsRule(context, (EnsureExprsRule) semanticObject); 
				return; 
			case UclidPackage.ENUM_REF:
				sequence_EnumRef(context, (EnumRef) semanticObject); 
				return; 
			case UclidPackage.ENUM_TYPE_RULE:
				sequence_EnumTypeRule(context, (EnumTypeRule) semanticObject); 
				return; 
			case UclidPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case UclidPackage.EXPR_LIST_RULE:
				sequence_ExprListRule(context, (ExprListRule) semanticObject); 
				return; 
			case UclidPackage.FOR_LOOP_RULE:
				sequence_ForLoopRule(context, (ForLoopRule) semanticObject); 
				return; 
			case UclidPackage.FUNC_DECL:
				if (rule == grammarAccess.getDeclRuleRule()
						|| rule == grammarAccess.getDefineDeclRuleRule()) {
					sequence_DefineDeclRule(context, (FuncDecl) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedObjectDeclRule()
						|| rule == grammarAccess.getFuncDeclRule()) {
					sequence_FuncDecl(context, (FuncDecl) semanticObject); 
					return; 
				}
				else break;
			case UclidPackage.FUNCTION_DECL:
				sequence_FunctionDecl(context, (FunctionDecl) semanticObject); 
				return; 
			case UclidPackage.ID_LIST_RULE:
				sequence_IdListRule(context, (IdListRule) semanticObject); 
				return; 
			case UclidPackage.IF_PRIMARY_EXPR:
				sequence_IfPrimaryExpr(context, (IfPrimaryExpr) semanticObject); 
				return; 
			case UclidPackage.IF_STMT_RULE:
				sequence_IfStmtRule(context, (IfStmtRule) semanticObject); 
				return; 
			case UclidPackage.INIT_DECL_RULE:
				sequence_InitDeclRule(context, (InitDeclRule) semanticObject); 
				return; 
			case UclidPackage.INPUT_DECL:
				sequence_InputDecl(context, (InputDecl) semanticObject); 
				return; 
			case UclidPackage.INPUTS_DECL_RULE:
				sequence_InputsDeclRule(context, (InputsDeclRule) semanticObject); 
				return; 
			case UclidPackage.INSTANCE_DECL:
				sequence_InstanceDeclRule(context, (InstanceDecl) semanticObject); 
				return; 
			case UclidPackage.INVARIANT_RULE:
				sequence_InvariantRule(context, (InvariantRule) semanticObject); 
				return; 
			case UclidPackage.MODIFIES_EXPRS_RULE:
				sequence_ModifiesExprsRule(context, (ModifiesExprsRule) semanticObject); 
				return; 
			case UclidPackage.MODULE:
				sequence_ModuleRule(context, (uclid.xtext.uclid.Module) semanticObject); 
				return; 
			case UclidPackage.NEXT_DECL_RULE:
				sequence_NextDeclRule(context, (NextDeclRule) semanticObject); 
				return; 
			case UclidPackage.OUTPUT_DECL:
				sequence_OutputDecl(context, (OutputDecl) semanticObject); 
				return; 
			case UclidPackage.OUTPUTS_DECL_RULE:
				sequence_OutputsDeclRule(context, (OutputsDeclRule) semanticObject); 
				return; 
			case UclidPackage.PROC_RETURN_ARG_RULE:
				sequence_ProcReturnArgRule(context, (ProcReturnArgRule) semanticObject); 
				return; 
			case UclidPackage.PROCEDURE_DECL:
				sequence_ProcedureDecl(context, (ProcedureDecl) semanticObject); 
				return; 
			case UclidPackage.PROPERTY_RULE:
				sequence_PropertyRule(context, (PropertyRule) semanticObject); 
				return; 
			case UclidPackage.RECORD_TYPE_RULE:
				sequence_RecordTypeRule(context, (RecordTypeRule) semanticObject); 
				return; 
			case UclidPackage.REQUIRE_EXPRS_RULE:
				sequence_RequireExprsRule(context, (RequireExprsRule) semanticObject); 
				return; 
			case UclidPackage.SHARED_VARS_DECL_RULE:
				sequence_SharedVarsDeclRule(context, (SharedVarsDeclRule) semanticObject); 
				return; 
			case UclidPackage.STATEMENT:
				sequence_StatementRule(context, (Statement) semanticObject); 
				return; 
			case UclidPackage.STATEMENT_RULE:
				sequence_StatementRule(context, (StatementRule) semanticObject); 
				return; 
			case UclidPackage.TOP_LEVEL:
				sequence_ModelRule(context, (TopLevel) semanticObject); 
				return; 
			case UclidPackage.TUPLE_EXPR:
				sequence_TupleExpr(context, (TupleExpr) semanticObject); 
				return; 
			case UclidPackage.TUPLE_TYPE_RULE:
				sequence_TupleTypeRule(context, (TupleTypeRule) semanticObject); 
				return; 
			case UclidPackage.TYPE:
				if (rule == grammarAccess.getPrimitiveTypeRuleRule()) {
					sequence_PrimitiveTypeRule(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRuleRule()) {
					sequence_PrimitiveTypeRule_TypeReference(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeReferenceRule()) {
					sequence_TypeReference(context, (Type) semanticObject); 
					return; 
				}
				else break;
			case UclidPackage.TYPE_DECL:
				sequence_TypeDeclRule(context, (TypeDecl) semanticObject); 
				return; 
			case UclidPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case UclidPackage.VAR_REFERENCE:
				sequence_VarReference(context, (VarReference) semanticObject); 
				return; 
			case UclidPackage.VARS_DECL_RULE:
				sequence_VarsDeclRule(context, (VarsDeclRule) semanticObject); 
				return; 
			case UclidPackage.WHILE_LOOP_RULE:
				sequence_WhileLoopRule(context, (WhileLoopRule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArgList returns ArgList
	 *
	 * Constraint:
	 *     (args+=VarDecl args+=VarDecl* t=TypeRule (args+=VarDecl args+=VarDecl* t=TypeRule)*)
	 */
	protected void sequence_ArgList(ISerializationContext context, ArgList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgMapListRule returns ArgMapListRule
	 *
	 * Constraint:
	 *     (arg+=ArgMapRule arg+=ArgMapRule*)?
	 */
	protected void sequence_ArgMapListRule(ISerializationContext context, ArgMapListRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgMapRule returns ArgMapRule
	 *
	 * Constraint:
	 *     (name=ID e+=ExprRule?)
	 */
	protected void sequence_ArgMapRule(ISerializationContext context, ArgMapRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRule returns ArrayTypeRule
	 *     ArrayTypeRule returns ArrayTypeRule
	 *
	 * Constraint:
	 *     (b+=TypeRule b+=TypeRule* base+=TypeRule)
	 */
	protected void sequence_ArrayTypeRule(ISerializationContext context, ArrayTypeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementRule returns Assignment
	 *     AssignmentRule returns Assignment
	 *
	 * Constraint:
	 *     (lhs+=VarReference lhs+=VarReference* exprs+=ExprRule exprs+=ExprRule*)
	 */
	protected void sequence_AssignmentRule(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns AxiomDeclRule
	 *     AxiomDeclRule returns AxiomDeclRule
	 *
	 * Constraint:
	 *     (n=ID? e=ExprRule)
	 */
	protected void sequence_AxiomDeclRule(ISerializationContext context, AxiomDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlkStmtRule returns CompoundStatement
	 *
	 * Constraint:
	 *     (dec+=VarsDeclRule* stmt+=StatementRule*)
	 */
	protected void sequence_BlkStmtRule(ISerializationContext context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementRule returns CallStatement
	 *     CallStatement returns CallStatement
	 *
	 * Constraint:
	 *     ((lhs+=VarReference lhs+=VarReference*)? target=FunctionReference (exprs+=ExprRule exprs+=ExprRule*)?)
	 */
	protected void sequence_CallStatement(ISerializationContext context, CallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseBlockRule returns CaseBlockRule
	 *
	 * Constraint:
	 *     (e=ExprRule body=BlkStmtRule)
	 */
	protected void sequence_CaseBlockRule(ISerializationContext context, CaseBlockRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.CASE_BLOCK_RULE__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.CASE_BLOCK_RULE__E));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.CASE_BLOCK_RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.CASE_BLOCK_RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseBlockRuleAccess().getEExprRuleParserRuleCall_0_0(), semanticObject.getE());
		feeder.accept(grammarAccess.getCaseBlockRuleAccess().getBodyBlkStmtRuleParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseStmtRule returns CaseStmtRule
	 *
	 * Constraint:
	 *     (cases+=CaseBlockRule | cases+=DefaultCaseBlockRule)*
	 */
	protected void sequence_CaseStmtRule(ISerializationContext context, CaseStmtRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CmdRule returns CmdRule
	 *
	 * Constraint:
	 *     (lhs=VarDecl? c=CmdNameRule lid=IdListRule? lex=ExprListRule?)
	 */
	protected void sequence_CmdRule(ISerializationContext context, CmdRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedObjectDecl returns ConstDecl
	 *     ConstDecl returns ConstDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ConstDecl(ISerializationContext context, ConstDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     E13Rule returns ConstRule
	 *     ConstRule returns ConstRule
	 *
	 * Constraint:
	 *     (v='false' | v='true' | (d=INT w=BV?) | v=STRING)
	 */
	protected void sequence_ConstRule(ISerializationContext context, ConstRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns ConstsDeclRule
	 *     ConstsDeclRule returns ConstsDeclRule
	 *
	 * Constraint:
	 *     (constants+=ConstDecl constants+=ConstDecl* t=TypeRule)
	 */
	protected void sequence_ConstsDeclRule(ISerializationContext context, ConstsDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ControlBlockRule returns ControlBlockRule
	 *
	 * Constraint:
	 *     cmd+=CmdRule*
	 */
	protected void sequence_ControlBlockRule(ISerializationContext context, ControlBlockRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefaultCaseBlockRule returns DefaultCaseBlockRule
	 *
	 * Constraint:
	 *     body=BlkStmtRule
	 */
	protected void sequence_DefaultCaseBlockRule(ISerializationContext context, DefaultCaseBlockRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.DEFAULT_CASE_BLOCK_RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.DEFAULT_CASE_BLOCK_RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultCaseBlockRuleAccess().getBodyBlkStmtRuleParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns FuncDecl
	 *     DefineDeclRule returns FuncDecl
	 *
	 * Constraint:
	 *     (name=ID inputs=ArgList t=TypeRule e=ExprRule)
	 */
	protected void sequence_DefineDeclRule(ISerializationContext context, FuncDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FUNC_DECL__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FUNC_DECL__INPUTS));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FUNC_DECL__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FUNC_DECL__T));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FUNC_DECL__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FUNC_DECL__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefineDeclRuleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefineDeclRuleAccess().getInputsArgListParserRuleCall_3_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getDefineDeclRuleAccess().getTTypeRuleParserRuleCall_6_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getDefineDeclRuleAccess().getEExprRuleParserRuleCall_8_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     E10Rule returns E10Rule
	 *
	 * Constraint:
	 *     (((op='-' | op='!' | op='~') e=E11Rule) | e=E11Rule)
	 */
	protected void sequence_E10Rule(ISerializationContext context, E10Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E11Rule returns E12Rule
	 *
	 * Constraint:
	 *     (j=E13Rule v=ExprListRule? (l+=ExprListRule (e+=ExprRule | e+=ExprRule)?)?)
	 */
	protected void sequence_E11Rule_E12Rule(ISerializationContext context, E12Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E12Rule returns E12Rule
	 *
	 * Constraint:
	 *     (j=E13Rule v=ExprListRule?)
	 */
	protected void sequence_E12Rule(ISerializationContext context, E12Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRule returns E1Rule
	 *     E1Rule returns E1Rule
	 *     E13Rule returns E1Rule
	 *     ParenthesisExpr returns E1Rule
	 *
	 * Constraint:
	 *     (((pred='forall' | pred='exists') existential=ArgList a=E1Rule) | (pred='const' existential=ExprListRule))
	 */
	protected void sequence_E1Rule(ISerializationContext context, E1Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprRule returns E2Rule
	 *     E1Rule returns E2Rule
	 *     E2Rule returns E2Rule
	 *     E13Rule returns E2Rule
	 *     ParenthesisExpr returns E2Rule
	 *
	 * Constraint:
	 *     (z+=E3Rule (op=LOGEQU (q+=E2Rule | q+=E3Rule))*)
	 */
	protected void sequence_E2Rule(ISerializationContext context, E2Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E3Rule returns E3Rule
	 *
	 * Constraint:
	 *     (e+=E4Rule (op=LOGIMPLY (e+=E3Rule | e+=E4Rule))*)
	 */
	protected void sequence_E3Rule(ISerializationContext context, E3Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E4Rule returns E4Rule
	 *
	 * Constraint:
	 *     (
	 *         (e+=E5Rule e+=E4Rule) | 
	 *         (e+=E5Rule e+=E4Rule) | 
	 *         (e+=E5Rule e+=E4Rule) | 
	 *         (e+=E5Rule e+=E4Rule) | 
	 *         (e+=E5Rule e+=E4Rule) | 
	 *         e+=E5Rule
	 *     )
	 */
	protected void sequence_E4Rule(ISerializationContext context, E4Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E5Rule returns E5Rule
	 *
	 * Constraint:
	 *     (e+=E6Rule (op=REL_OP_RULE e+=E6Rule)*)
	 */
	protected void sequence_E5Rule(ISerializationContext context, E5Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E6Rule returns E6Rule
	 *
	 * Constraint:
	 *     (e+=E7Rule e+=E6Rule*)
	 */
	protected void sequence_E6Rule(ISerializationContext context, E6Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E7Rule returns E7Rule
	 *
	 * Constraint:
	 *     (e+=E8Rule e+=E7Rule*)
	 */
	protected void sequence_E7Rule(ISerializationContext context, E7Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E8Rule returns E8Rule
	 *
	 * Constraint:
	 *     (e+=E9Rule e+=E9Rule*)
	 */
	protected void sequence_E8Rule(ISerializationContext context, E8Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E9Rule returns E9Rule
	 *
	 * Constraint:
	 *     (e+=E10Rule e+=E10Rule*)
	 */
	protected void sequence_E9Rule(ISerializationContext context, E9Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnsureExprsRule returns EnsureExprsRule
	 *
	 * Constraint:
	 *     e=ExprRule
	 */
	protected void sequence_EnsureExprsRule(ISerializationContext context, EnsureExprsRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.ENSURE_EXPRS_RULE__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.ENSURE_EXPRS_RULE__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnsureExprsRuleAccess().getEExprRuleParserRuleCall_1_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     E13Rule returns EnumRef
	 *     EnumRef returns EnumRef
	 *
	 * Constraint:
	 *     _enum=[EnumValue|FQN]
	 */
	protected void sequence_EnumRef(ISerializationContext context, EnumRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.ENUM_REF__ENUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.ENUM_REF__ENUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumRefAccess().get_enumEnumValueFQNParserRuleCall_0_1(), semanticObject.eGet(UclidPackage.Literals.ENUM_REF__ENUM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeRule returns EnumTypeRule
	 *     EnumTypeRule returns EnumTypeRule
	 *
	 * Constraint:
	 *     (enums+=EnumValue enums+=EnumValue*)
	 */
	protected void sequence_EnumTypeRule(ISerializationContext context, EnumTypeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExprListRule returns ExprListRule
	 *
	 * Constraint:
	 *     (exprs+=ExprRule exprs+=ExprRule*)
	 */
	protected void sequence_ExprListRule(ISerializationContext context, ExprListRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForLoopRule returns ForLoopRule
	 *
	 * Constraint:
	 *     (iterator=VarDecl lb=ConstRule ub=ConstRule body=BlkStmtRule)
	 */
	protected void sequence_ForLoopRule(ISerializationContext context, ForLoopRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__LB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__LB));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__UB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__UB));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FOR_LOOP_RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopRuleAccess().getIteratorVarDeclParserRuleCall_1_0(), semanticObject.getIterator());
		feeder.accept(grammarAccess.getForLoopRuleAccess().getLbConstRuleParserRuleCall_5_0(), semanticObject.getLb());
		feeder.accept(grammarAccess.getForLoopRuleAccess().getUbConstRuleParserRuleCall_7_0(), semanticObject.getUb());
		feeder.accept(grammarAccess.getForLoopRuleAccess().getBodyBlkStmtRuleParserRuleCall_9_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedObjectDecl returns FuncDecl
	 *     FuncDecl returns FuncDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FuncDecl(ISerializationContext context, FuncDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns FunctionDecl
	 *     FunctionDecl returns FunctionDecl
	 *
	 * Constraint:
	 *     (name=ID inputs=ArgList t=TypeRule)
	 */
	protected void sequence_FunctionDecl(ISerializationContext context, FunctionDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FUNC_DECL__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FUNC_DECL__INPUTS));
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.FUNC_DECL__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.FUNC_DECL__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionDeclAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionDeclAccess().getInputsArgListParserRuleCall_5_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getFunctionDeclAccess().getTTypeRuleParserRuleCall_8_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IdListRule returns IdListRule
	 *
	 * Constraint:
	 *     (name+=ID | (name+=ID l=IdListRule))
	 */
	protected void sequence_IdListRule(ISerializationContext context, IdListRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E13Rule returns IfPrimaryExpr
	 *     IfPrimaryExpr returns IfPrimaryExpr
	 *
	 * Constraint:
	 *     (c=ExprRule e+=ExprRule e+=ExprRule)
	 */
	protected void sequence_IfPrimaryExpr(ISerializationContext context, IfPrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmtRule returns IfStmtRule
	 *
	 * Constraint:
	 *     (c=ExprRule then=BlkStmtRule else=BlkStmtRule?)
	 */
	protected void sequence_IfStmtRule(ISerializationContext context, IfStmtRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns InitDeclRule
	 *     InitDeclRule returns InitDeclRule
	 *
	 * Constraint:
	 *     body=BlkStmtRule
	 */
	protected void sequence_InitDeclRule(ISerializationContext context, InitDeclRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.INIT_DECL_RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.INIT_DECL_RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitDeclRuleAccess().getBodyBlkStmtRuleParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedObjectDecl returns InputDecl
	 *     InputDecl returns InputDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InputDecl(ISerializationContext context, InputDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns InputsDeclRule
	 *     InputsDeclRule returns InputsDeclRule
	 *
	 * Constraint:
	 *     (inputs+=InputDecl inputs+=InputDecl* t=TypeRule)
	 */
	protected void sequence_InputsDeclRule(ISerializationContext context, InputsDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns InstanceDecl
	 *     InstanceDeclRule returns InstanceDecl
	 *
	 * Constraint:
	 *     (name=ID module=[Module|FQN] args+=ArgMapListRule)
	 */
	protected void sequence_InstanceDeclRule(ISerializationContext context, InstanceDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns InvariantRule
	 *     SpecDeclRule returns InvariantRule
	 *     InvariantRule returns InvariantRule
	 *
	 * Constraint:
	 *     (name=ID? e=ExprRule)
	 */
	protected void sequence_InvariantRule(ISerializationContext context, InvariantRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelRule returns TopLevel
	 *
	 * Constraint:
	 *     rules+=ModuleRule*
	 */
	protected void sequence_ModelRule(ISerializationContext context, TopLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModifiesExprsRule returns ModifiesExprsRule
	 *
	 * Constraint:
	 *     l=IdListRule
	 */
	protected void sequence_ModifiesExprsRule(ISerializationContext context, ModifiesExprsRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.MODIFIES_EXPRS_RULE__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.MODIFIES_EXPRS_RULE__L));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModifiesExprsRuleAccess().getLIdListRuleParserRuleCall_1_0(), semanticObject.getL());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleRule returns Module
	 *
	 * Constraint:
	 *     (name=ID d+=DeclRule* e=ControlBlockRule?)
	 */
	protected void sequence_ModuleRule(ISerializationContext context, uclid.xtext.uclid.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns NextDeclRule
	 *     NextDeclRule returns NextDeclRule
	 *
	 * Constraint:
	 *     body=BlkStmtRule
	 */
	protected void sequence_NextDeclRule(ISerializationContext context, NextDeclRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.NEXT_DECL_RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.NEXT_DECL_RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNextDeclRuleAccess().getBodyBlkStmtRuleParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedObjectDecl returns OutputDecl
	 *     OutputDecl returns OutputDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_OutputDecl(ISerializationContext context, OutputDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns OutputsDeclRule
	 *     OutputsDeclRule returns OutputsDeclRule
	 *
	 * Constraint:
	 *     (outputs+=OutputDecl outputs+=OutputDecl* t=TypeRule)
	 */
	protected void sequence_OutputsDeclRule(ISerializationContext context, OutputsDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimitiveTypeRule returns Type
	 *
	 * Constraint:
	 *     (t='boolean' | t='integer' | t=BV)
	 */
	protected void sequence_PrimitiveTypeRule(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRule returns Type
	 *
	 * Constraint:
	 *     (decl=FQN | t='boolean' | t='integer' | t=BV)
	 */
	protected void sequence_PrimitiveTypeRule_TypeReference(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcReturnArgRule returns ProcReturnArgRule
	 *
	 * Constraint:
	 *     output=ArgList
	 */
	protected void sequence_ProcReturnArgRule(ISerializationContext context, ProcReturnArgRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.PROC_RETURN_ARG_RULE__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.PROC_RETURN_ARG_RULE__OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcReturnArgRuleAccess().getOutputArgListParserRuleCall_2_0(), semanticObject.getOutput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns ProcedureDecl
	 *     ProcedureDecl returns ProcedureDecl
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inputs=ArgList 
	 *         ret=ProcReturnArgRule? 
	 *         req+=RequireExprsRule* 
	 *         ensure+=EnsureExprsRule* 
	 *         modifies+=ModifiesExprsRule* 
	 *         body=BlkStmtRule
	 *     )
	 */
	protected void sequence_ProcedureDecl(ISerializationContext context, ProcedureDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns PropertyRule
	 *     SpecDeclRule returns PropertyRule
	 *     PropertyRule returns PropertyRule
	 *
	 * Constraint:
	 *     (name=ID? e=ExprRule)
	 */
	protected void sequence_PropertyRule(ISerializationContext context, PropertyRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRule returns RecordTypeRule
	 *     RecordTypeRule returns RecordTypeRule
	 *
	 * Constraint:
	 *     (fields+=VarDecl fields+=VarDecl* type=TypeRule (fields+=VarDecl fields+=VarDecl* type=TypeRule)*)?
	 */
	protected void sequence_RecordTypeRule(ISerializationContext context, RecordTypeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequireExprsRule returns RequireExprsRule
	 *
	 * Constraint:
	 *     e=ExprRule
	 */
	protected void sequence_RequireExprsRule(ISerializationContext context, RequireExprsRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.REQUIRE_EXPRS_RULE__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.REQUIRE_EXPRS_RULE__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequireExprsRuleAccess().getEExprRuleParserRuleCall_1_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns SharedVarsDeclRule
	 *     SharedVarsDeclRule returns SharedVarsDeclRule
	 *
	 * Constraint:
	 *     (vars+=VarDecl vars+=VarDecl* t=TypeRule)
	 */
	protected void sequence_SharedVarsDeclRule(ISerializationContext context, SharedVarsDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementRule returns Statement
	 *
	 * Constraint:
	 *     (
	 *         d=ExprRule | 
	 *         d=ExprRule | 
	 *         name=ID | 
	 *         name=ID | 
	 *         s=IfStmtRule | 
	 *         s=CaseStmtRule | 
	 *         s=ForLoopRule | 
	 *         s=WhileLoopRule | 
	 *         s=BlkStmtRule
	 *     )
	 */
	protected void sequence_StatementRule(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementRule returns StatementRule
	 *
	 * Constraint:
	 *     {StatementRule}
	 */
	protected void sequence_StatementRule(ISerializationContext context, StatementRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E13Rule returns TupleExpr
	 *     TupleExpr returns TupleExpr
	 *
	 * Constraint:
	 *     (e+=ExprRule e+=ExprRule*)
	 */
	protected void sequence_TupleExpr(ISerializationContext context, TupleExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRule returns TupleTypeRule
	 *     TupleTypeRule returns TupleTypeRule
	 *
	 * Constraint:
	 *     (tuple+=TypeRule tuple+=TypeRule*)
	 */
	protected void sequence_TupleTypeRule(ISerializationContext context, TupleTypeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns TypeDecl
	 *     TypeDeclRule returns TypeDecl
	 *
	 * Constraint:
	 *     ((name=ID? t=TypeRule) | name=ID)
	 */
	protected void sequence_TypeDeclRule(ISerializationContext context, TypeDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns Type
	 *
	 * Constraint:
	 *     decl=FQN
	 */
	protected void sequence_TypeReference(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPE__DECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPE__DECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getDeclFQNParserRuleCall_0(), semanticObject.getDecl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedObjectDecl returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UclidPackage.Literals.TYPED_OBJECT_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarReference returns VarReference
	 *
	 * Constraint:
	 *     (index+=ExprRule index+=ExprRule*)
	 */
	protected void sequence_VarReference(ISerializationContext context, VarReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclRule returns VarsDeclRule
	 *     VarsDeclRule returns VarsDeclRule
	 *
	 * Constraint:
	 *     (vars+=VarDecl vars+=VarDecl* t=TypeRule)
	 */
	protected void sequence_VarsDeclRule(ISerializationContext context, VarsDeclRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileLoopRule returns WhileLoopRule
	 *
	 * Constraint:
	 *     (c=ExprRule inv+=SpecDeclRule* stmt=BlkStmtRule)
	 */
	protected void sequence_WhileLoopRule(ISerializationContext context, WhileLoopRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
