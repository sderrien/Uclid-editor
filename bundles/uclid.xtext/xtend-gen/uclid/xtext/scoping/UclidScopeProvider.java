/**
 * generated by Xtext 2.22.0
 */
package uclid.xtext.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import uclid.xtext.uclid.CallStatement;
import uclid.xtext.uclid.InstanceDecl;
import uclid.xtext.uclid.ProcedureDecl;
import uclid.xtext.uclid.SynonymTypeRule;
import uclid.xtext.uclid.TypeDecl;
import uclid.xtext.uclid.VarDecl;
import uclid.xtext.uclid.VarRef;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class UclidScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
  public uclid.xtext.uclid.Module getModule(final EObject e) {
    return EcoreUtil2.<uclid.xtext.uclid.Module>getContainerOfType(e, uclid.xtext.uclid.Module.class);
  }
  
  public Iterable<Pair<VarDecl, QualifiedName>> getLocalVarsDecl(final uclid.xtext.uclid.Module module) {
    Iterable<Pair<VarDecl, QualifiedName>> _xblockexpression = null;
    {
      final Set<VarDecl> allLocalDecls = IteratorExtensions.<VarDecl>toSet(Iterators.<VarDecl>filter(module.eAllContents(), VarDecl.class));
      final Function1<VarDecl, Pair<VarDecl, QualifiedName>> _function = (VarDecl it) -> {
        QualifiedName _create = QualifiedName.create(it.getName());
        return Pair.<VarDecl, QualifiedName>of(it, _create);
      };
      _xblockexpression = IterableExtensions.<VarDecl, Pair<VarDecl, QualifiedName>>map(allLocalDecls, _function);
    }
    return _xblockexpression;
  }
  
  public Iterable<Pair<VarDecl, QualifiedName>> getInstanceLocalVarsDecl(final InstanceDecl instance) {
    Iterable<Pair<VarDecl, QualifiedName>> _xblockexpression = null;
    {
      final Set<VarDecl> allLocalDecls = IteratorExtensions.<VarDecl>toSet(Iterators.<VarDecl>filter(instance.getModule().eAllContents(), VarDecl.class));
      final Function1<VarDecl, Pair<VarDecl, QualifiedName>> _function = (VarDecl it) -> {
        String _name = instance.getName();
        String _name_1 = it.getName();
        QualifiedName _create = QualifiedName.create(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_name, _name_1)));
        return Pair.<VarDecl, QualifiedName>of(it, _create);
      };
      _xblockexpression = IterableExtensions.<VarDecl, Pair<VarDecl, QualifiedName>>map(allLocalDecls, _function);
    }
    return _xblockexpression;
  }
  
  public Iterable<Pair<VarDecl, QualifiedName>> getVarsInScope(final EObject e) {
    Iterable<Pair<VarDecl, QualifiedName>> _xblockexpression = null;
    {
      final uclid.xtext.uclid.Module module = EcoreUtil2.<uclid.xtext.uclid.Module>getContainerOfType(e, uclid.xtext.uclid.Module.class);
      final Set<VarDecl> allLocalDecls = IteratorExtensions.<VarDecl>toSet(Iterators.<VarDecl>filter(module.eAllContents(), VarDecl.class));
      final Set<InstanceDecl> allInstanceDecls = IteratorExtensions.<InstanceDecl>toSet(Iterators.<InstanceDecl>filter(module.eAllContents(), InstanceDecl.class));
      final Function1<InstanceDecl, Iterable<Pair<VarDecl, QualifiedName>>> _function = (InstanceDecl it) -> {
        return this.getInstanceLocalVarsDecl(it);
      };
      IterableExtensions.<Pair<VarDecl, QualifiedName>>toSet(Iterables.<Pair<VarDecl, QualifiedName>>concat(IterableExtensions.<InstanceDecl, Iterable<Pair<VarDecl, QualifiedName>>>map(allInstanceDecls, _function)));
      final EObject root = EcoreUtil2.getRootContainer(e);
      final Set<VarDecl> allDecls = IteratorExtensions.<VarDecl>toSet(Iterators.<VarDecl>filter(root.eAllContents(), VarDecl.class));
      final Function1<VarDecl, Pair<VarDecl, QualifiedName>> _function_1 = (VarDecl it) -> {
        QualifiedName _create = QualifiedName.create(it.getName());
        return Pair.<VarDecl, QualifiedName>of(it, _create);
      };
      Iterable<Pair<VarDecl, QualifiedName>> _map = IterableExtensions.<VarDecl, Pair<VarDecl, QualifiedName>>map(allLocalDecls, _function_1);
      final Function1<VarDecl, Pair<VarDecl, QualifiedName>> _function_2 = (VarDecl it) -> {
        QualifiedName _xblockexpression_1 = null;
        {
          String _name = this.getModule(it).getName();
          String _name_1 = it.getName();
          final QualifiedName qname = QualifiedName.create(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_name, _name_1)));
          _xblockexpression_1 = qname;
        }
        return Pair.<VarDecl, QualifiedName>of(it, _xblockexpression_1);
      };
      Iterable<Pair<VarDecl, QualifiedName>> _map_1 = IterableExtensions.<VarDecl, Pair<VarDecl, QualifiedName>>map(allDecls, _function_2);
      Set<Pair<VarDecl, QualifiedName>> _set = IterableExtensions.<Pair<VarDecl, QualifiedName>>toSet(Iterables.<Pair<VarDecl, QualifiedName>>concat(_map, _map_1));
      final Function1<InstanceDecl, Iterable<Pair<VarDecl, QualifiedName>>> _function_3 = (InstanceDecl it) -> {
        return this.getInstanceLocalVarsDecl(it);
      };
      Set<Pair<VarDecl, QualifiedName>> _set_1 = IterableExtensions.<Pair<VarDecl, QualifiedName>>toSet(Iterables.<Pair<VarDecl, QualifiedName>>concat(IterableExtensions.<InstanceDecl, Iterable<Pair<VarDecl, QualifiedName>>>map(allInstanceDecls, _function_3)));
      final Iterable<Pair<VarDecl, QualifiedName>> res = Iterables.<Pair<VarDecl, QualifiedName>>concat(_set, _set_1);
      _xblockexpression = res;
    }
    return _xblockexpression;
  }
  
  public Set<Pair<uclid.xtext.uclid.Module, QualifiedName>> getModuleInScope(final EObject e) {
    Set<Pair<uclid.xtext.uclid.Module, QualifiedName>> _xblockexpression = null;
    {
      final EObject root = EcoreUtil2.getRootContainer(e);
      final Set<uclid.xtext.uclid.Module> allDecls = IteratorExtensions.<uclid.xtext.uclid.Module>toSet(Iterators.<uclid.xtext.uclid.Module>filter(root.eAllContents(), uclid.xtext.uclid.Module.class));
      final Function1<uclid.xtext.uclid.Module, Pair<uclid.xtext.uclid.Module, QualifiedName>> _function = (uclid.xtext.uclid.Module it) -> {
        QualifiedName _xblockexpression_1 = null;
        {
          String _name = this.getModule(it).getName();
          final QualifiedName qname = QualifiedName.create(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_name)));
          _xblockexpression_1 = qname;
        }
        return Pair.<uclid.xtext.uclid.Module, QualifiedName>of(it, _xblockexpression_1);
      };
      final Set<Pair<uclid.xtext.uclid.Module, QualifiedName>> res = IterableExtensions.<Pair<uclid.xtext.uclid.Module, QualifiedName>>toSet(IterableExtensions.<uclid.xtext.uclid.Module, Pair<uclid.xtext.uclid.Module, QualifiedName>>map(allDecls, _function));
      _xblockexpression = res;
    }
    return _xblockexpression;
  }
  
  public Set<Pair<ProcedureDecl, QualifiedName>> getProcsInScope(final EObject e) {
    Set<Pair<ProcedureDecl, QualifiedName>> _xblockexpression = null;
    {
      final uclid.xtext.uclid.Module module = EcoreUtil2.<uclid.xtext.uclid.Module>getContainerOfType(e, uclid.xtext.uclid.Module.class);
      final Set<ProcedureDecl> allLocalDecls = IteratorExtensions.<ProcedureDecl>toSet(Iterators.<ProcedureDecl>filter(module.eAllContents(), ProcedureDecl.class));
      final EObject root = EcoreUtil2.getRootContainer(e);
      final Set<ProcedureDecl> allDecls = IteratorExtensions.<ProcedureDecl>toSet(Iterators.<ProcedureDecl>filter(root.eAllContents(), ProcedureDecl.class));
      final Function1<ProcedureDecl, Pair<ProcedureDecl, QualifiedName>> _function = (ProcedureDecl it) -> {
        QualifiedName _create = QualifiedName.create(it.getName());
        return Pair.<ProcedureDecl, QualifiedName>of(it, _create);
      };
      Iterable<Pair<ProcedureDecl, QualifiedName>> _map = IterableExtensions.<ProcedureDecl, Pair<ProcedureDecl, QualifiedName>>map(allLocalDecls, _function);
      final Function1<ProcedureDecl, Pair<ProcedureDecl, QualifiedName>> _function_1 = (ProcedureDecl it) -> {
        QualifiedName _xblockexpression_1 = null;
        {
          String _name = this.getModule(it).getName();
          String _name_1 = it.getName();
          final QualifiedName qname = QualifiedName.create(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(_name, _name_1)));
          _xblockexpression_1 = qname;
        }
        return Pair.<ProcedureDecl, QualifiedName>of(it, _xblockexpression_1);
      };
      Iterable<Pair<ProcedureDecl, QualifiedName>> _map_1 = IterableExtensions.<ProcedureDecl, Pair<ProcedureDecl, QualifiedName>>map(allDecls, _function_1);
      final Set<Pair<ProcedureDecl, QualifiedName>> res = IterableExtensions.<Pair<ProcedureDecl, QualifiedName>>toSet(Iterables.<Pair<ProcedureDecl, QualifiedName>>concat(_map, _map_1));
      _xblockexpression = res;
    }
    return _xblockexpression;
  }
  
  protected IScope _getScope(final VarRef context, final EReference reference) {
    String _name = reference.getName();
    boolean _equals = Objects.equal(_name, "var");
    if (_equals) {
      final Iterable<Pair<VarDecl, QualifiedName>> allQNames = this.getVarsInScope(context);
      final Function1<Pair<VarDecl, QualifiedName>, EObjectDescription> _function = (Pair<VarDecl, QualifiedName> it) -> {
        QualifiedName _value = it.getValue();
        VarDecl _key = it.getKey();
        return new EObjectDescription(_value, _key, null);
      };
      Set<EObjectDescription> objdesr = IterableExtensions.<EObjectDescription>toSet(IterableExtensions.<Pair<VarDecl, QualifiedName>, EObjectDescription>map(allQNames, _function));
      return new SimpleScope(IScope.NULLSCOPE, ((Iterable) objdesr));
    }
    return IScope.NULLSCOPE;
  }
  
  protected IScope _getScope(final InstanceDecl context, final EReference reference) {
    final EObject root = EcoreUtil2.getRootContainer(context);
    if ((Objects.equal(reference.getName(), "module") && (root != null))) {
      final Set<uclid.xtext.uclid.Module> allDecls = IteratorExtensions.<uclid.xtext.uclid.Module>toSet(Iterators.<uclid.xtext.uclid.Module>filter(root.eAllContents(), uclid.xtext.uclid.Module.class));
      final Function1<uclid.xtext.uclid.Module, EObjectDescription> _function = (uclid.xtext.uclid.Module it) -> {
        EObjectDescription _xblockexpression = null;
        {
          final String label = it.getName();
          final QualifiedName qname = this.getQualifiedNameConverter().toQualifiedName(label);
          _xblockexpression = new EObjectDescription(qname, it, null);
        }
        return _xblockexpression;
      };
      Set<EObjectDescription> objdesr = IterableExtensions.<EObjectDescription>toSet(IterableExtensions.<uclid.xtext.uclid.Module, EObjectDescription>map(allDecls, _function));
      return new SimpleScope(IScope.NULLSCOPE, ((Iterable) objdesr));
    }
    return IScope.NULLSCOPE;
  }
  
  protected IScope _getScope(final CallStatement context, final EReference reference) {
    String _name = reference.getName();
    boolean _equals = Objects.equal(_name, "var");
    if (_equals) {
      final Set<Pair<ProcedureDecl, QualifiedName>> allQNames = this.getProcsInScope(context);
      final Function1<Pair<ProcedureDecl, QualifiedName>, EObjectDescription> _function = (Pair<ProcedureDecl, QualifiedName> it) -> {
        QualifiedName _value = it.getValue();
        ProcedureDecl _key = it.getKey();
        return new EObjectDescription(_value, _key, null);
      };
      Set<EObjectDescription> objdesr = IterableExtensions.<EObjectDescription>toSet(IterableExtensions.<Pair<ProcedureDecl, QualifiedName>, EObjectDescription>map(allQNames, _function));
      return new SimpleScope(IScope.NULLSCOPE, ((Iterable) objdesr));
    }
    return IScope.NULLSCOPE;
  }
  
  /**
   * Find the first object which is an instance of a subtype of <code>c</code>
   * in the eContainer chain. Returns null if none is found.
   * 
   * @param current
   * @param eclass
   * @return
   */
  public static <T extends EObject> T eContainerTypeSelect(final EObject _current, final Class<T> c) {
    EObject current = _current;
    while ((current != null)) {
      {
        boolean _isInstance = c.isInstance(current);
        if (_isInstance) {
          final T current2 = ((T) current);
          return current2;
        }
        current = current.eContainer();
      }
    }
    return null;
  }
  
  protected IScope _getScope(final SynonymTypeRule context, final EReference reference) {
    final EObject root = EcoreUtil2.getRootContainer(context);
    if ((Objects.equal(reference.getName(), "decl") && (root != null))) {
      final Set<TypeDecl> allDecls = IteratorExtensions.<TypeDecl>toSet(Iterators.<TypeDecl>filter(root.eAllContents(), TypeDecl.class));
      final Function1<TypeDecl, EObjectDescription> _function = (TypeDecl it) -> {
        EObjectDescription _xblockexpression = null;
        {
          final String label = it.getName();
          final QualifiedName qname = this.getQualifiedNameConverter().toQualifiedName(label);
          _xblockexpression = new EObjectDescription(qname, it, null);
        }
        return _xblockexpression;
      };
      Set<EObjectDescription> objdesr = IterableExtensions.<EObjectDescription>toSet(IterableExtensions.<TypeDecl, EObjectDescription>map(allDecls, _function));
      final uclid.xtext.uclid.Module module = UclidScopeProvider.<uclid.xtext.uclid.Module>eContainerTypeSelect(context, uclid.xtext.uclid.Module.class);
      final Function1<TypeDecl, EObjectDescription> _function_1 = (TypeDecl it) -> {
        EObjectDescription _xblockexpression = null;
        {
          final String label = it.getName();
          QualifiedName _create = QualifiedName.create(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(label)));
          _xblockexpression = new EObjectDescription(_create, it, null);
        }
        return _xblockexpression;
      };
      Iterable<EObjectDescription> _map = IterableExtensions.<TypeDecl, EObjectDescription>map(Iterables.<TypeDecl>filter(module.getD(), TypeDecl.class), _function_1);
      Iterables.<EObjectDescription>addAll(objdesr, _map);
      return new SimpleScope(IScope.NULLSCOPE, ((Iterable) objdesr));
    }
    return IScope.NULLSCOPE;
  }
  
  public IScope getScope(final EObject context, final EReference reference) {
    if (context instanceof CallStatement) {
      return _getScope((CallStatement)context, reference);
    } else if (context instanceof InstanceDecl) {
      return _getScope((InstanceDecl)context, reference);
    } else if (context instanceof SynonymTypeRule) {
      return _getScope((SynonymTypeRule)context, reference);
    } else if (context instanceof VarRef) {
      return _getScope((VarRef)context, reference);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(context, reference).toString());
    }
  }
}
